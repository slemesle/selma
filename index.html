<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
     <meta name="Description" content=" Selma - Java bean mapping that compiles">
    <title>Selma</title>
    <link rel="stylesheet" href="css/normalize.min.css">
    <link rel="stylesheet" href="css/style.css">
    <link rel="shortcut icon" href="favicon.ico">
      <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>
      <script>window.jQuery || document.write('<script src="js/vendor/jquery-1.10.1.min.js"><\/script>')</script>
      <script src="js/jquery.smoothscroll.js"></script>
    <script>
      setTimeout(function(){
        $('body').addClass('onload');
      }, 0);

    </script>
      <script src="js/vendor/modernizr-2.6.2-respond-1.1.0.min.js"></script>
      <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
      <!--[if lt IE 9]>
    <script src="html5shiv.js"></script>
    <![endif]-->
  </head>
  <body>
    <a href="https://github.com/xebia-france/selma"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>

    <section id="header" style="display: none;">
        <div class="wrapper">
            <div class="left"><a href="/" alt="Selma Homepage">S3lm4</a></div>
            <ul>
                <li><a href="#why" data-speed="500" data-easing="easeInOutCubic" data-url="false" class="nav">Why</a></li>
                <li><a href="#tutorial" data-speed="500" data-easing="easeInOutCubic" data-url="false"  class="nav">Tutorial</a></li>
                <li><a href="#documentation" data-speed="500" data-easing="easeInOutCubic" data-url="false" class="nav">Documentation</a></li>
            </ul>
            <div class="right">
                <a href="https://travis-ci.org/xebia-france/selma"><img class="travis" src="https://travis-ci.org/xebia-france/selma.png?branch=master" alt="Build Status"></a></li>
                <!--<a href="#header" alt="Go to Top" class="nav">Top</a>-->
            </div>
        </div>

    </section>
    <section id="content">
    <h1><a href="http://xebia-france.github.io/selma"><img src="img/logo-v6-medium.png" alt="S3lm4 logo"/></a> </h1>
    <p id="tag">Selma - Java bean mapping that compiles !</p>
    <p>Selma stand for Stupid Simple Statically Linked Mapper, it generates static code to map properties from one bean to another. We <em>K</em>eep <em>I</em>t <em>S</em>tupid <em>S</em>imple: convention over configuration, light footprint, easy ot use, easy to learn, are Selma's roots. On one side, Selma is an <em>Annotation Processor</em> that generate Java code to handle the mapping from field to field at <em>compile time</em>. On the over side, it is an API to instantiate and invoke the generated Mapper implementation.</p>

    <h2 id="why">Why another Java mapping framework ?</h2>

    <p>Existing frameworks massively use reflection API to build dynamically the maping code. Well let me see, it's fine ! In fact, it can be, but the better mapping framework I know is vanilla Java code with it's long list of if conditions. Because performance are far better, and I have total control on the mapping. More over, the static code is refactoring proof, and easy to debug. But that is painful :p. Writing all this code is always my preferred part, almost always since there is sometime more than 3 poor little beans. That's where Selma comes, the idea is simple get advantages of the manual mapping without the pain.</p>

    <h2 id="tutorial">The 1 minute tutorial</h2>
    <p class="bullet-point">First add Selma to your <em>pom</em></p>

        <pre class="prettyprint language-xml"><code>&lt;!-- scope provided because the processor is only needed for the compiler --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;fr.xebia.extras&lt;/groupId&gt;
        &lt;artifactId&gt;selma-processor&lt;/artifactId&gt;
        &lt;version&gt;0.3&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!-- This is the only real dependency you will have in youre binaries --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;fr.xebia.extras&lt;/groupId&gt;
        &lt;artifactId&gt;selma&lt;/artifactId&gt;
        &lt;version&gt;0.3&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>

    <p><i>There are 2 artifacts</i></p>
    <ul>
      <li><em>selma-processor</em> - contains the annotation processor and the code generation part. It should be in a provided scope because we need it only at compilation time.</li>
      <li><em>selma</em> - contains the API to work with the generated mappers. We use the default scope because we need the API at runtime.</li>
    </ul>

    <p class="bullet-point">Then declare your mapper</p>

<pre class="prettyprint language-xml"><code>@Mapper
public interface SelmaMapper {
    OutBean asOutBean(InBean in);
}
</code></pre>

    <p><i>Here we've defined SelmaMapper which maps InBean to an instance of OutBean.</i></p>
    <p class="bullet-point">Finally, use the mapper</p>

<pre class="prettyprint language-java"><code>// Get SelmaMapper
SelmaMapper mapper = Selma.getMapper(SelmaMapper.class);

// Map my InBean
OutBean res = mapper.asOutBean(in);
</code></pre>

    <p class="bullet-point">Build and enjoy!</p>
    <p>Any issue will be reported in the compiler log, it will also give you fix tips.</p>
    <p><a href="https://github.com/xebia-france/selma/tree/master/examples">Check our sample app project in github.</a></p>

    </section>

    <section id="documentation">
        <h1>Documentation</h1>
        <p>This is where you go when get stuck ! First keep in mind that Selma knows only one thing, generate implementation code for mapper interface.</p>
        <h2 id="mapping">Mapping</h2>
        <p>Selma match fields using setter and getter names. What does this mean ? Selma match can map only same field names. We only use setters and getters so don't worry about the inner field name.</p>
        <p class="alert alert-danger">By default, missing properties aka properties from in bean does not match any field in out bean and reverse, will break compilation.</p>
        <h2>Let see an example</h2>
        <p class="bullet-point">First the model object a Person :</p>

<pre class="prettyprint language-java"><code>public class Person {

    private String firstName;
    private String lastName;
    private Date birthDay;
    private int age;
    private Long[] indices;
    private Collection tags;

    // + Getters and Setters
}</code></pre>
        <p class="bullet-point">Then the DTO a PersonDto :</p>
<pre class="prettyprint language-java"><code>public class PersonDto {

    private String firstName;
    private String lastName;
    private Date birthDay;
    private int age;
    private Long[] indices;
    private List tags;

    // + Getters and Setters
}</code></pre>
        <p class="bullet-point">Now we define the Mapper interface :</p>
<pre class="prettyprint language-java"><code>@Mapper
    public interface PersonMapper {

    PersonDto asPersonDto(Person in);
}</code></pre>
        <p>All properties are exactly matching so this will work.</p>
        <p class="bullet-point">Generated code is:</p>
<pre class="prettyprint language-java"><code>// GENERATED BY S3LM4
package fr.xebia.extras.selma.beans;

public final class PersonMapperSelmaGeneratedClass
    implements PersonMapper {

  /**
   * Single constructor
   */
  public PersonMapperSelmaGeneratedClass() {
  }

  /**
   * Mapping method overridden by Selma
   */
  @Override
  public final PersonDto asPersonDto(Person in) {
    fr.xebia.extras.selma.beans.PersonDto out = null;
    if (in != null) {
      out = new fr.xebia.extras.selma.beans.PersonDto();
      if (in.getTags() != null) {
        java.util.ArrayList _TagsTmpCollection = new java.util.ArrayList(in.getTags().size());
        out.setTags(_TagsTmpCollection);
        for (java.lang.String _TagsItem : in.getTags()) {
          if (_TagsItem != null) {
            _TagsTmpCollection.add(new java.lang.String(_TagsItem));
          }
          else {
            _TagsTmpCollection.add(null);
          }
        }
      }
      else {
        out.setTags(null);
      }
      out.setAge(in.getAge());
      if (in.getBirthDay() != null) {
        out.setBirthDay(new java.util.Date(in.getBirthDay().getTime()));
      }
      else {
        out.setBirthDay(null);
      }
      if (in.getFirstName() != null) {
        out.setFirstName(new java.lang.String(in.getFirstName()));
      }
      else {
        out.setFirstName(null);
      }
      if (in.getIndices() != null) {
        java.lang.Long[] _IndicesTmpArray = new java.lang.Long[in.getIndices().length];
        int _IndicesTotalCount = in.getIndices().length;
        out.setIndices(_IndicesTmpArray);
        for (int aIndicesIndex = 0 ; aIndicesIndex < _IndicesTotalCount; aIndicesIndex++) {
          if (in.getIndices()[aIndicesIndex%in.getIndices().length] != null) {
            _IndicesTmpArray[aIndicesIndex%in.getIndices().length] = new java.lang.Long(in.getIndices()[aIndicesIndex%in.getIndices().length]);
          }
          else {
            _IndicesTmpArray[aIndicesIndex%in.getIndices().length] = null;
          }
        }
      }
      else {
        out.setIndices(null);
      }
      if (in.getLastName() != null) {
        out.setLastName(new java.lang.String(in.getLastName()));
      }
      else {
        out.setLastName(null);
      }
    }
    return out;
  }

}</code></pre>
        <p><span class="disclaimer">Add the generated source to youre IDE</span><br/>Using a maven build, you will find the generated sources under target/generated-sources/annotations.</p>

        <h2>Mapper class</h2>
        <p>All mappers are generated using the name of the interface with a suffix SelmaGeneratedClass. The class are generated in the same package as the interface and declared final.</p>

        <h2>Null values</h2>
        <p>Selma generated code always protect against NPE. The mapper will process mapping if value is not null else the mapper will explicitly set null to the destination bean.</p>

        <h2>Strict copy</h2>
        <p>Selma warrants immutability of the in bean, all values setted in the destination bean are strict copy of original values.</p>

        <h2 id="ignore-fields">Ignore fields</h2>
        <p>
            Selma makes strict copy, so it will try to match each single property. When matching properties are
            not found in source or destination bean, the compiler will fail reporting missing properties.

        </p>
        <p>
            At this point, you have 2 solutions:
        <ul>
            <li>Use the <code>ignoreMissingProperties</code> <code>@Mapper</code> attribute, to totally
                disable this strict behavior and silently ignore missing properties.</li>
            <li>Use the <code>@IgnoreFields</code> annotation, to list explicitly fields that will be
                ignored at compile time.</li>
        </ul>
        </p>

            <h3>Scope the <code>@IgnoreFields</code></h3>
            <p>
                You can define this annotation either at the class level of the Mapper interface, or for specific
                mapping methods.
            </p>

        <h2>Enumerations</h2>
        <p>
            Default behavior, is to consider that all values in source enum exists in destination enum. We take great care to build a separate method that will be used
            every time the same enum to enum mapping is needed. This method maps using a Switch block without default.
        </p>
        <p>
            In some situation, you'll need more than the default behavior. The EnumMapper annotation is there for you, with it, Selma will use a slightly different strategy.
            The processor will still build a separate method but this time it map only identical values from both enums and use the given default value.
            This annotation can be used at interface level inside the Mapper annotation.
        </p>

         <pre class="prettyprint language-java">
@Mapper( enums = @EnumMapper(from=EnumA.class, to=EnumB.class, defaultValue="UNKNOWN"))
public interface PersonMapper {

    PersonDto asPersonDto(Person in);

}
         </pre>

        <p>
            But you can also use it at method level.
        </p>

        <pre class="prettyprint language-java">
@Mapper
public interface PersonMapper {

    @EnumMapper(defaultValue="UNKNOWN")
    EnumB asEnumB(EnumA in);

}
         </pre>

        <p>
            <span class="disclaimer">All parameters are optional but ...</span><br/>
            At class level, you need to specify from and to, if you don't specify defaultValue it will defaults to null in generated code.
            At method level, if in and out types are enums, you won't need to specify from and to.
        </p>

        <h2>Field name mapping</h2>
        <p>By default the generated mapper, will map fields with same name. But you can also specify a custom name to name mapping using the @Field annotation.</p>
        <p>@Field are defined in the fields parameter of the @Mapper annotation, it contains the list of custom field name mapping.
           See below, we map the field "nom" to "lastname" and the field "prenom" to "firstname".
        </p>
            <pre class="prettyprint language-java">
@Mapper(ignoreMissingProperties = true, fields={
        @Field({"nom", "lastname"}), @Field({"prenom", "firstname"})
})
public interface CustomFieldMapper {

    SimplePersonDto convertFrom(SimplePerson in);

}
         </pre>


        <h2>Nested bean</h2>
        <p>Mapper code will declare a single separated method for each nested bean in the graph.</p>

        <p><span class="disclaimer">Declare nested bean methods</span><br/>
        Selma will override the methods defined in the mapper interface and use it everywhere it is needed. If they are declared, you will be able to use them from the interface.</p>

        <h2>Collections and Maps</h2>
        <h3>Collections</h3>
        <p>Selma detects class implementing java.util.Collection and either use a default implementation, or the given one.
        This means that Selma can convert any Collection to another Collection class. Let say you have a LinkedList in the inBean and an ArrayList in the out bean or you want to convert from Collection type to a Set.</p>

        <h3>Maps</h3>
        <p>Selma will also process the mapping of <code>java.util.Map</code> ensuring that both the Key and the values will be converted as any type.
            Both key and value are subject to mapping, so Pojo will be mapped in both case.
        </p>


                <h3>Defaults</h3>
                <p> Selma uses default collection implementation, when mapping requires to return an interface. See the table below to find corresponding implementation.</p>
                <table class="table table-striped">
                    <thead>
                    <tr>
                        <th>Interface</th>
                        <th>Implementation</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>Set</td>
                        <td>HashSet</td>
                    </tr>
                    <tr>
                        <td>SortedSet</td>
                        <td>TreeSet</td>
                    </tr>
                    <tr>
                        <td>BlockingDeque</td>
                        <td>LinkedBlockingDeque</td>
                    </tr>
                    <tr>
                        <td>BlockingQueue</td>
                        <td>LinkedBlockingQueue</td>
                    </tr>
                    <tr>
                        <td>Queue</td>
                        <td>PriorityQueue</td>
                    </tr>
                    <tr>
                        <td>Deque</td>
                        <td>ArrayDeque</td>
                    </tr>
                    <tr>
                        <td>List</td>
                        <td>ArrayList</td>
                    </tr>
                    <tr>
                        <td>NavigableSet</td>
                        <td>ConcurrentSkipListSet</td>
                    </tr>
                    <tr>
                        <td>Map</td>
                        <td>HashMap</td>
                    </tr>
                    <tr>
                        <td>ConcurrentMap</td>
                        <td>ConcurrentHashMap</td>
                    </tr>
                    <tr>
                        <td>ConcurrentNavigableMap</td>
                        <td>ConcurrentSkipListMap</td>
                    </tr>
                    <tr>
                        <td>NavigableMap</td>
                        <td>TreeMap</td>
                    </tr>
                    <tr>
                        <td>SortedMap</td>
                        <td>TreeMap</td>
                    </tr>
                    <tr>
                        <td>Collection</td>
                        <td>ArrayList</td>
                    </tr>
                    </tbody>
                </table>

        <h2 id="custom-mapper">Custom Mapper</h2>
        <p>
            Sometimes, Selma will not do what you need. Let say, you want to convert from String to date or from Integer to Float.
            In Selma, we do not want magic conversion, so converting from boxed Integer to native int and reverse is supported but,
            we do not support auto-magically convert from int to float because there can be data loss. So you can define youre own custom mapper.
        </p>
        <p>
            A custom mapper is a class that contains methods one or more methods taking an input parameter (the source bean / value)
            and return the destination value after hand coded mapping. You only need to add the class to the
            <code>withMapper</code> attribute of the <code>@Mapper</code> annotation.
        </p>
        <h3>Let see it</h3>
        <p>First, we add an address field to Person and PersonDto classes.</p>

           <pre class="prettyprint language-java">
public class Person {

    private String firstName;
    // ...
    private Address address;

               // + Getters and Setters
}
</pre>

        <p>
            Here address is stored in a nested bean, but in PersonDto:
        </p>
<pre class="prettyprint language-java">
public class PersonDto {

    private String firstName;
    // ...
    private String address;
    // + Getters and Setters
}
</pre>

        <p>
            We use a simple String to store the address so on mapping we want to serialize the Address to String in PersonDTO.
            Now lets define the CustomMapper:
        </p>
<pre class="prettyprint language-java">
public class AddressMapper {

    public String addressToString (Address in) {
        return in.toString();
    }
}
</pre>
        <p>
            For simplicity, we use the toString() method to demonstrate the feature. The method name is not relevant since Selma only match methods
            based on the modifier, return type and single parameter type.
            Compiler will report Custom Mapper miss use.

        </p>

        <p>Finally, we should define the Mapper interface:</p>
<pre class="prettyprint language-java">
@Mapper( withMapper = AddressMapper.class )
public interface PersonMapper {

    PersonDto asPersonDto(Person in);

}
</pre>

        <p>Here we are, the custom mapper is now called from Selma generated base code to map our address field from Address class to String.</p>

            <p>
            <span class="disclaimer">Custom Mapper Tips</span><br/>
                You can define multiple mapping methods in a CustomMapper class. But you can also, define multiple CustomMapper in the <code>@Mapper</code>
                definition.
            </p>
            <p>
                Just remember, for selma method name is nothing, just ensure to define the good In/Out type pair.
            </p>

        <h2>Mapper interceptor</h2>
        <p>
            Not convince by custom mapper, you need to do special things on the source or target bean after the mapping occurs.
            Selma, allows you to define a hook in the custom mapper wich will be executed after the mapping itself.
            </p>
        <p>
            You just need to define a method returning void and taking two parameters the in bean and the out bean. See the example below:
        </p>
        <pre class="prettyprint language-java">
public class AddressMapper {

    public void addressToString (Address in, AddressDto out) {
        // Do some processing here the out is already filled in using in.
    }
}
</pre>

        <h2 id="sourced-beans">Sourced beans</h2>
        <p>
           <span class="disclaimer">  Sourced beans ? What do you mean ?</span><br/>
            In some case, the beans needs to be bound to DataSource. With most libraries you'll need to provide a
            Factory that will be called to get an instance of the targeted bean. But this kind of behaviour drives
            the developer to use Reflection during the mapping. STOP, this breaks our philosophy because we want static compile code.
        </p>
        <p>
            So how does Selma do ? Well, what we support is passing one or more object to the bean constructor.
            Doing this we are able to pass a DataSource object to the bean. The only, constraints are to pass the
            source to Selma when retrieving the generated Mapper and to declare sources type in the mapper interface.
        </p>
 <pre class="prettyprint language-java">
@Mapper(withSource = DataSource.class)
public interface SourcedBeanMapper {

    AddressOutWithDataSource asAddressOut(AddressIn in);
}
</pre>

        <p>Below is the out class:</p>
<pre class="prettyprint language-java">
public class AddressOutWithDataSource {

    // ...
    public final DataSource dataSource;

    public AddressOutWithDataSource(DataSource dataSource) {
       this.dataSource = dataSource;
    }

    // ...
}
</pre>

        <p>Now you can retrieve, the mapper by passing the dataSource:</p>
 <pre class="prettyprint language-java">
       DataSource dataSource = new DataSource();
       SourcedBeanMapper mapper = Selma.getMapper(SourcedBeanMapper.class, dataSource);
</pre>

            <p>
            <span class="disclaimer"> Never forget constructors</span><br/>
                For sourced beans, Selma will call a constructor passing the source in the same exact order as
                defined in <code>@Mapper</code>. So ensure, that you have defined the constructors, and don't forget
                custom mappers !
            </p>


    </section>

    <footer>
      <span>© Séven Le Mesle and Xebia 2014</span>
    </footer>


  <script type="text/javascript">
      // Show or hide fixed menu
      var menuFixed = false,
      $menuFixed = $("#header");
      var i=0;
      $(window).scroll(function () {
          if ($(window).scrollTop() > 149) {
              if (menuFixed === false) {
                  $menuFixed.slideDown("0.2");
                  menuFixed = true;
              }
          } else {
              if (menuFixed === true) {
                  $menuFixed.slideUp("0.2");
                  menuFixed = false;
              }
          }
      });

      $( function () {
          $('html').smoothScroll(500);
      });

  </script>
  </body>
</html>